1) Por que a função questao_1() calcula os respectivos epsilons
   e.g.: float float_epsilon = 1.0f;
         while (1.0f + float_epsilon != 1.0f)
           float_epsilon *= 0.5f;
         
         float_epsilon = 2.0f;
   
   equivalente para double e long double.

   Resposta) Em aritmética de ponto flutuante, um número x é
             representado da seguinte forma (float):
             
             x = +- 2^{exp} * 1,(mantissa)

             sendo que exp é um número que, em binário, tem
             8 bits. Ou seja, pode ir de -128 até 127. Dessa
             forma, quando x é dividido por dois, subtrai-se
             1 do valor de exp. Para double, exp tem 11 bits.
             Consideraremos float_epsilon = x para facilitar.
             Para que x = 1.0f nesse formato, exp = 0 e
             todos os digitos da mantissa são iguais a 0 também.
             O valor de exp é subtraído em 1 a cada vez que
             x é multiplicado por 0.5f (dividio por 2 em outras
             palavras) enquanto os digitos da mantissa se mantém
             iguais a 0.
             Quando a soma 1.0f + x finalmente for igual a 1.0f,
             significa que x é o maior número menor que
             FLT_EPSILON e, portanto, deve ser multiplicada por
             2.0f para que volte a ficar igual a FLT_EPSILON.
             Os digitos da mantissa devem ser sempre 0 para
             que seja o menor possível.

2) Por que o código abaixo calcula o maior float finito?
   
   float_max = 1.0f;
   while (4.0f * float_max != 8.0f * float_max)
     float_max *= 2.0f;
   
   float_max *= (4.0f * (1.0f - 0.5f * FLT_EPSILON));

   Equivalente para double e long double.

   Resposta) O processo é semelhante ao do item anterior.
             Quando float_max é multiplicado por 2.0f, exp
             é incrementado em 1, até que uma hora a
             multiplicação 4.0f * float_max se torna igual
             a infinito. Consequentemente, 8.0f * float_max
             também se torna igual a infinito e o programa
             sai do while().
             Para que se obtenha o maior float finito, é
             preciso multiplicar float_max pelo número
             imediatamente menor que 4.0f. Isso é obtido
             ao multiplicar float_max por
             4.0f * (1.0f - 0.5f * FLT_EPSILON).
             O equivalente ocorre para double e long double.

3) Por que o código calcula o menor float diferente de zero?
   
   float_min = 1.0f
   while (0.5f * float_min != 0.0f)
     float_min *= 0.5f;

   equivalente para double e long double.

   Resposta) 

4) Por o código calcula o menor float normal e o que
   é um float normal?

   FLT_TRUE_MIN / FLT_EPSILON

   Resposta) Como explicado anteriormente, em ponto flutuante,
             um número x pode ser escrito da seguinte forma
             se for float:

             x = +- 2^{exp} * 1.(mantissa)

             sendo que exp é um número com 8 bits em binário
             (11 se for double). Dessa forma, exp pode assumir
             qualquer valor inteiro no intervalo [-128, 127].
             Quando escrito dessa forma, ele é chamado de normal.
             Se estiver escrito na forma

             x = +- 2^{exp} * 0.(mantissa)

             dado que exp = menor possível (-128 se for float),
             esse número é chamado de subnormal. Os números
             subnormais compreendem o intervalo entre 0 e o
             menor float normal. Os números nesse intervalo
             estão igualmente espaçados um do outro e dos limites
             (0 e o menor float normal).
             FLT_TRUE_MIN é o menor número subnormal que o
             computador consegue representar, enquanto FLT_MIN
             é o menor número normal. Ao dividir FLT_TRUE_MIN
             por FLT_EPSILON, que é a diferençe entre 1 e o menor
             float maior que 1
